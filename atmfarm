

-- Define a global table with alternate usernames
getgenv().alts = {
    Alt1 = "vdhcdropper65", -- Replace with the first alt username
    Alt2 = "vdhcdropper66", -- Replace with the second alt username
    Alt3 = "hifortnitekids2" -- Replace with the third alt username
}

-- Persistent table to track ongoing trades
local ongoingTrades = {}

-- Function to wait for a player with an indefinite wait
local function waitForPlayer(playerName)
    while true do
        local player = game.Players:FindFirstChild(playerName)
        if player then
            return player
        end
        task.wait(1) -- Check every second
    end
end

-- Function to count active alts
local function getActiveAlts()
    local activeAlts = {}
    for _, altUsername in pairs(getgenv().alts) do
        local altPlayer = game.Players:FindFirstChild(altUsername)
        if altPlayer then
            table.insert(activeAlts, altPlayer)
        end
    end
    return activeAlts
end

-- Function to resume or perform trading
local function performTrade(recipientUsername, totalTools)
    -- Save or load trade state
    local tradeState = ongoingTrades[recipientUsername] or {remainingTools = totalTools}
    tradeState.totalTools = totalTools
    ongoingTrades[recipientUsername] = tradeState

    -- Wait for the recipient player to join, even if they join later
    local recipient = waitForPlayer(recipientUsername)

    if not recipient then
        print("Recipient not found.")
        return
    end

    local activeAlts = getActiveAlts()
    local numAlts = #activeAlts
    if numAlts == 0 then
        print("No alts available to trade.")
        return
    end

    -- Calculate tools per alt
    local toolsPerAlt = math.floor(tradeState.remainingTools / numAlts)
    local extraTools = tradeState.remainingTools % numAlts

    print("Total tools: " .. tradeState.totalTools)
    print("Active alts: " .. numAlts)
    print("Tools per alt: " .. toolsPerAlt)
    print("Extra tools to distribute: " .. extraTools)

    -- Trade tools from each alt
    for index, altPlayer in ipairs(activeAlts) do
        local backpack = altPlayer:FindFirstChild("Backpack")
        local tools = {}
        if backpack then
            for _, item in pairs(backpack:GetChildren()) do
                if item:IsA("Tool") and item.Name ~= "Treasure Map" then -- Skip "Treasure Map"
                    table.insert(tools, item)
                end
            end
        end

        local toolsToOffer = toolsPerAlt

        -- Distribute extra tools to the first few alts
        if extraTools > 0 then
            toolsToOffer = toolsToOffer + 1
            extraTools = extraTools - 1
        end

        print(altPlayer.Name .. " is set to trade " .. toolsToOffer .. " tools.")
        while toolsToOffer > 0 and tradeState.remainingTools > 0 do
            local tool = table.remove(tools, 1) -- Take the first tool available
            if tool and altPlayer.Character and altPlayer.Character:FindFirstChild("Humanoid") then
                altPlayer.Character.Humanoid:EquipTool(tool)
                task.wait(0.2) -- Wait between equipping items
                local offerEvent = tool:FindFirstChild("offer")
                if offerEvent then
                    local args = {recipient}
                    offerEvent:FireServer(unpack(args))
                    toolsToOffer = toolsToOffer - 1
                    tradeState.remainingTools = tradeState.remainingTools - 1
                    print("Offered tool: " .. tool.Name)
                else
                    print("Failed to offer " .. tool.Name .. ". Trying a different tool.")
                    table.insert(tools, tool) -- Reinsert the tool for retry
                end
            end
            -- Refresh tool list if empty
            if #tools == 0 and backpack then
                for _, item in pairs(backpack:GetChildren()) do
                    if item:IsA("Tool") and item.Name ~= "Treasure Map" and not table.find(tools, item) then
                        table.insert(tools, item)
                    end
                end
            end
            -- Prevent infinite loop if tools are exhausted
            if #tools == 0 then
                break
            end
        end

        if toolsToOffer > 0 then
            print(altPlayer.Name .. " ran out of tools before completing their trade.")
        end
    end

    -- Final check for any unoffered tools
    if tradeState.remainingTools > 0 then
        print("Not all tools could be traded. Remaining: " .. tradeState.remainingTools)
    else
        print("Trade successful. All " .. tradeState.totalTools .. " tools have been offered.")
        ongoingTrades[recipientUsername] = nil -- Clear trade state on completion
    end
end

-- Function to handle commands
local function handleCommand(command)
    if command:lower() == ".setup" then
        print("Setup command executed.")
    else
        -- Match the .tradeall command with arguments
        local recipientUsername, amountOfTools = command:match("^%.tradeall%s+([%w_]+)%s+(%d+)$")
        amountOfTools = tonumber(amountOfTools)
        if recipientUsername and amountOfTools then
            performTrade(recipientUsername, amountOfTools)
        else
            print("Invalid .tradeall command. Use the format: .tradeall <recipient_username> <amount>")
        end
    end
end

-- WebSocket connection
local ws = WebSocket.connect("ws://192.168.1.18:8765")
if ws then
    print("Connected to WebSocket!")
    ws.OnMessage:Connect(function(msg)
        print("Command received via WebSocket: " .. msg)
        handleCommand(msg)
    end)
    ws.OnClose:Connect(function()
        print("WebSocket connection closed.")
    end)
else
    print("Failed to connect to WebSocket.")
end


-- Ensure the script runs properly when executed
local worldFolder = workspace:FindFirstChild("world")

-- Check if the world folder exists
if worldFolder then
    local mapFolder = worldFolder:FindFirstChild("map")
    if mapFolder then
        -- Destroy all children of the map folder
        for _, child in pairs(mapFolder:GetChildren()) do
            child:Destroy()
        end
    end
end


game:GetService("RunService"):Set3dRenderingEnabled(false)
pcall(function() UserSettings().GameSettings.MasterVolume = 0 end)
pcall(function() settings().Rendering.QualityLevel = "Level01" end)

setfpscap(7)

-- Get the player's character
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Get the character's position
local position = character:FindFirstChild("HumanoidRootPart") and character.HumanoidRootPart.Position
if position then
    -- Create a baseplate under the player
    local baseplate = Instance.new("Part")
    baseplate.Size = Vector3.new(50, 1, 50) -- Adjust the size of the baseplate as needed
    baseplate.Position = Vector3.new(position.X, position.Y - 3, position.Z) -- Position below the player
    baseplate.Anchored = true
    baseplate.BrickColor = BrickColor.new("Medium stone grey")
    baseplate.Parent = workspace
end

wait(50)
game:GetService("RunService"):Set3dRenderingEnabled(true)
